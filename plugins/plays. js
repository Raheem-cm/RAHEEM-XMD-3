 const { cmd } = require('../command');
const axios = require('axios');
const fs = require('fs');
const { promisify } = require('util');
const writeFileAsync = promisify(fs.writeFile);

cmd({
    pattern: "plays",
    desc: "Search and download music from YouTube",
    react: "ðŸŽµ",
    category: "media",
    filename: __filename
},
async (conn, mek, m, { from, reply, text }) => {
    try {
        if (!text) {
            const help = `
ðŸŽµ *MUSIC DOWNLOADER* ðŸŽµ

*Usage:* .play [song name/artist]
*Examples:*
â€¢ .play diamond platnumz waah
â€¢ .play harmonize never give up
â€¢ .play jux you
â€¢ .play rayvanny kwetu

*Features:*
â€¢ Search and download music
â€¢ Multiple quality options
â€¢ Get song information
â€¢ Fast download

*Note:* Music is downloaded from YouTube.
`;
            return reply(help);
        }

        // Show searching message
        await reply(`ðŸ” *Searching for:* "${text}"\nâ³ Please wait...`);

        // Step 1: Search for music
        const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(text)}+music+official&type=video&key=AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8&maxResults=5`;
        
        const searchResponse = await axios.get(searchUrl);
        const videos = searchResponse.data.items;
        
        if (!videos || videos.length === 0) {
            return reply(`âŒ No results found for "${text}"\nTry different keywords.`);
        }

        // Prepare search results
        let resultsList = `ðŸŽµ *SEARCH RESULTS*\n\n`;
        videos.forEach((video, index) => {
            const title = video.snippet.title;
            const channel = video.snippet.channelTitle;
            resultsList += `${index + 1}. ${title}\n   ðŸ‘¤ ${channel}\n\n`;
        });
        
        resultsList += `*Reply with:* .play [number]\nExample: .play 1`;
        
        // Store search results for this user
        const userId = m.sender;
        global.searchCache = global.searchCache || {};
        global.searchCache[userId] = {
            videos: videos,
            query: text,
            timestamp: Date.now()
        };

        // Clean old cache after 5 minutes
        setTimeout(() => {
            if (global.searchCache && global.searchCache[userId]) {
                delete global.searchCache[userId];
            }
        }, 300000);

        await reply(resultsList);

    } catch (e) {
        console.error("Search error:", e);
        await reply(`âŒ Search failed\nError: ${e.message || "Unknown error"}`);
    }
});

// Handle selection and download
cmd({
    pattern: "play",
    desc: "Download selected music",
    react: "â¬‡ï¸",
    category: "media",
    filename: __filename
},
async (conn, mek, m, { from, reply, text, sender }) => {
    try {
        // Check if user is selecting from search results
        const userId = sender;
        const cache = global.searchCache && global.searchCache[userId];
        
        if (cache && !isNaN(text) && text >= 1 && text <= 5) {
            const index = parseInt(text) - 1;
            const video = cache.videos[index];
            
            if (!video) {
                return reply("âŒ Invalid selection");
            }

            const videoId = video.id.videoId;
            const title = video.snippet.title;
            const channel = video.snippet.channelTitle;
            const thumbnail = video.snippet.thumbnails.high.url;

            // Show downloading message
            await reply(`â¬‡ï¸ *Downloading:* ${title}\nðŸ‘¤ ${channel}\n\nâ³ Converting to audio... Please wait.`);

            try {
                // Try ytdl-core first
                const ytdl = require('ytdl-core');
                const info = await ytdl.getInfo(`https://youtube.com/watch?v=${videoId}`);
                
                // Get audio format
                const audioFormat = ytdl.chooseFormat(info.formats, { quality: 'highestaudio' });
                
                if (!audioFormat) {
                    throw new Error("No audio format found");
                }

                // Download and send
                const audioStream = ytdl(`https://youtube.com/watch?v=${videoId}`, {
                    quality: 'highestaudio',
                    filter: 'audioonly'
                });

                // Create buffer
                const chunks = [];
                for await (const chunk of audioStream) {
                    chunks.push(chunk);
                }
                const buffer = Buffer.concat(chunks);

                // Prepare message
                const message = `
âœ… *DOWNLOAD COMPLETE*

ðŸŽµ *Title:* ${title}
ðŸ‘¤ *Channel:* ${channel}
ðŸ“Š *Quality:* ${audioFormat.audioBitrate}kbps
â±ï¸ *Duration:* ${info.videoDetails.lengthSeconds} seconds

ðŸ“¥ *Sending audio file...*
`;

                await reply(message);

                // Send audio file
                await conn.sendMessage(from, {
                    audio: buffer,
                    mimetype: 'audio/mpeg',
                    fileName: `${title.replace(/[^\w\s]/gi, '')}.mp3`,
                    ptt: false
                }, { quoted: m });

                // Clean cache
                delete global.searchCache[userId];

            } catch (ytdlError) {
                console.log("YTDL failed, trying alternative:", ytdlError);
                
                // Alternative: Use y2mate API
                const apiUrl = `https://api.y2mate.guru/api/convert?url=https://youtube.com/watch?v=${videoId}`;
                const apiResponse = await axios.get(apiUrl);
                
                if (apiResponse.data && apiResponse.data.url) {
                    const audioUrl = apiResponse.data.url;
                    
                    // Download audio
                    const audioResponse = await axios.get(audioUrl, { responseType: 'arraybuffer' });
                    const audioBuffer = Buffer.from(audioResponse.data, 'binary');
                    
                    const message = `
âœ… *DOWNLOAD COMPLETE*

ðŸŽµ *Title:* ${title}
ðŸ‘¤ *Channel:* ${channel}
ðŸ“¥ *Via:* y2mate API

*Sending audio file...*
`;
                    
                    await reply(message);
                    
                    await conn.sendMessage(from, {
                        audio: audioBuffer,
                        mimetype: 'audio/mpeg',
                        fileName: `${title.substring(0, 50)}.mp3`,
                        ptt: false
                    }, { quoted: m });
                    
                    delete global.searchCache[userId];
                } else {
                    throw new Error("All download methods failed");
                }
            }

        } else if (text) {
            // If text is provided but not a number 1-5, treat as new search
            return; // Let the first handler catch it
        }

    } catch (e) {
        console.error("Download error:", e);
        
        // Try alternative method
        try {
            const userId = sender;
            const cache = global.searchCache && global.searchCache[userId];
            
            if (cache && text && !isNaN(text) && text >= 1 && text <= 5) {
                const index = parseInt(text) - 1;
                const video = cache.videos[index];
                const videoId = video.id.videoId;
                const title = video.snippet.title;
                
                // Last resort: Send YouTube link
                await reply(`
ðŸŽµ *Alternative Download*

*Title:* ${title}
*YouTube Link:* https://youtu.be/${videoId}

*You can:*
1. Open link and use other downloader
2. Try again later
3. Search different song

*Error:* ${e.message || "Download failed"}
`);
                
                delete global.searchCache[userId];
            }
        } catch (finalError) {
            await reply("âŒ Download failed. Please try different song or try again later.");
        }
    }
});
